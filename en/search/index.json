[{"content":"The installation is quite tricky.\nDownload Termux You can choose which termux version, but right now I\u0026rsquo;m using this.\nDownload Termux 0.118.0\nInstallation The Installation is simple, you just need to this command:\n1 2 3 4 5 6 7 pkg update \u0026amp;\u0026amp; pkg upgrade -y pkg install openssl-tool nodejs-lts git python3 build-essential git android-tools -y git clone https://github.com/NetrisTV/ws-scrcpy cd ws-scrcpy npm install -g node-gyp npm ci npm run start Thats all.\nTroubleshoot You may encounter a problem while install, latest version need to install pupeter (the correct name is puppeteer and hard to write) in ws-scrcpy, i dont know why, but quick fix is using .puppeteerrc.cjs for able to install pupeter, you may take a look example usage from https://github.com/anasfanani/ilmupedia-auto-buy/blob/main/.puppeteerrc.cjs\nCreate a new file in ws-scrcpy folder named as .puppeteerrc.cjs and fill with:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const { join } = require(\u0026#39;path\u0026#39;); let config = {}; if (process.env.PREFIX === \u0026#39;/data/data/com.termux/files/usr\u0026#39;) { config.executablePath = \u0026#39;/data/data/com.termux/files/usr/bin/chromium-browser\u0026#39;; } config.cacheDirectory = join(__dirname, \u0026#39;.cache\u0026#39;, \u0026#39;puppeteer\u0026#39;); /** * @type {import(\u0026#34;puppeteer\u0026#34;).Configuration} */ module.exports = config; Before run npm ci again, you need to run this command first:\n1 2 3 pkg install tur-repo x11-repo pkg update pkg install chromium Then run npm ci again.\n","date":"2024-04-01T08:50:00+07:00","permalink":"https://anasfanani.com/en/p/websocket-scrcpy-ws-scrcpy-with-termux/","title":"WebSocket ScrCpy (ws-scrcpy) With Termux"},{"content":"Shell Compiler Shell compiler source code can be found at this repo https://github.com/neurobin/shc.\nYou may need to read the README.md at their repo carefully .\nQuick Start A quickstart for usage the shc a.k.a shell compiler from me:\nBuild from source using GitHub codespace Go to github codespace https://github.com/codespaces and create new, or you may go to https://github.com/neurobin/shc and select create codespace.\nThen input this command to configure.\n1 2 3 4 5 git clone https://github.com/neurobin/shc cd shc ./configure make sudo make install Create simple file named as test.sh :\n1 2 3 4 #!/bin/sh echo \u0026#34;hello world\u0026#34; id uname -a Then use shc with this command :\n1 shc -f test.sh We got two file, test.sh.x and test.sh.c, for now while type this article, i dont know at much what is test.sh.c file for.\nLets chmod for allow executing the binary.\n1 chmod +x ./test.sh.x Then execute the binary :\n1 ./test.sh.x Sample output :\n1 2 3 4 @anasfanani ➜ /workspaces/ (master) $ ./test.sh.x hello world uid=1000(codespace) gid=1000(codespace) groups=1000(codespace),106(ssh),107(docker),988(pipx),989(python),990(oryx),991(golang),992(sdkman),993(rvm),994(php),995(conda),996(nvs),997(nvm),998(hugo),999(dotnet) Linux codespaces-67d0c2 5.15.0-1041-azure #48-Ubuntu SMP Tue Jun 20 20:34:08 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux Trying to read the file with cat ./test.sh.x | head -n 2 :\n1 2 3 4 5 6 7 @@@@��3@8 � ��kX���O�퐖��GNU��@��ݣk�e�mĹ�@9��a \u0026gt;S-Z�rLy��; �(����Q�tdR�td-==��/lib64/ld-linux-x86-64.so.2GNU�GNU�� �J E��!��!��\u0026#34;����libc.so.6exitsprintf__isoc99_sscanftime__stack_chk_failgetpidstrdupcallocstrlenmemset__errno_locationmemcmpputenvmemcpymallocgetenvs�����iieuipfwrit@�?��?�?�?�B�B(?0?8?@?H?P?X?trer`?r__libc_start_main__environ__xstatGLIBC_2.7GLIBC_2.14GLIBC_2.4GLIBC_2.2.5_ITM_deregisterTMCloneTable__gmon_start___ITM_registerTMCloneTableii h? p? �?�?�?�?�?�?�?�?�?�?�?��H�H��/H��t��H���5�.��%�.��h���������h���������h���������h��������h��������h��������h��������h��q��������a������h ��Q������h Then using file test.sh.x :\n1 test.sh.x: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=bcdc0dde1319c86b5802a7b9c34f9eed909684e2, for GNU/Linux 3.2.0, stripped Deobfuscate / Decompile Found how to decompile the binary from https://github.com/neurobin/shc/issues/99.\nQuick Start Lets try the quickstart from me using this snippet :\n1 2 3 4 git clone https://github.com/niansa/bash-shxdumper cd bash-shxdumper ./configure make -j$(nproc) || make At this point, we got new modified ./bash file, now move this bash file to the system :\n1 sudo mv /bin/bash /bin/bash.bak \u0026amp;\u0026amp; sudo cp ./bash /bin/bash Dont worry, your original bash is backup to /bin/bash.bak, I dont need told you about this.\nNow we try to deobfuscate ./test.sh.x files :\n1 OUTFILE=./decrypted.sh ./test.sh.x And result is failed to deobfuscate ( -_- ).\nIt seems the shc update their code, shxdumper doesnt work again.\nI have another trick to show the running code from process, while you run a shx code, you can see the source with ps -aux | grep ./test.sh.x the code is showing in process list, but you cant see again if process already killed, thats all I know.\nI wont write much more because I\u0026rsquo;m boring and this blog is for my personal note.\n","date":"2024-04-01T08:24:00+07:00","permalink":"https://anasfanani.com/en/p/shell-script-compiler-/-encoder-and-how-to-decode/","title":"Shell Script Compiler / Encoder, And How To Decode"},{"content":"This is how to set up MITM proxy and proxychains4 in Linux Ubuntu.\nSetup Mitm Proxy Update and install mitmproxy\n1 2 sudo apt update sudo apt install mitmproxy -y Run and install certificate\nRef : Certificates\nRun with :\n1 mitmweb --no-web-open-browser --web-host 0.0.0.0 Then install certificate\n1 2 3 4 5 curl --proxy 127.0.0.1:8080 --cacert ~/.mitmproxy/mitmproxy-ca-cert.pem https://example.com/ openssl x509 -in ~/.mitmproxy/mitmproxy-ca-cert.pem -inform PEM -out ~/.mitmproxy/mitmproxy-ca-cert.crt sudo mkdir /usr/local/share/ca-certificates/extra sudo cp ~/.mitmproxy/mitmproxy-ca-cert.crt /usr/local/share/ca-certificates/extra/mitmproxy-ca-cert.crt sudo update-ca-certificates Verify certificate and https mitm is working\n1 curl https://ipinfo.io -x 0.0.0.0:8080 -v Setup Proxychains4 1 2 3 sudo apt install proxychains4 -y sudo sed -i -e \u0026#39;s/proxy_dns/# proxy_dns/g\u0026#39; -e \u0026#39;s/socks4\\s\\+127.0.0.1\\s\\+9050/# socks4 127.0.0.1 9050/g\u0026#39; -e \u0026#39;$a\\http 0.0.0.0 8080\u0026#39; /etc/proxychains4.conf proxychains4 curl https://ipinfo.io ","date":"2024-04-01T08:00:00+07:00","permalink":"https://anasfanani.com/en/p/mitm-proxy-and-proxy-chain-linux-programs-in-ubuntu/","title":"Mitm Proxy And Proxy Chain Linux Programs In Ubuntu"},{"content":"Greeting Test every proxy program on https://sing-box.sagernet.org/configuration/inbound/\nWelcome, this is my environment :\n1 2 3 4 5 6 7 Linux ip-xxx-xxx-xxx-xxx 6.2.0-1013-xxx #13~22.04.1-Ubuntu SMP Fri Sep 8 17:29:56 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux ubuntu@ip-xxx-xxx-xxx-xxx:~$ cat /etc/lsb-release DISTRIB_ID=Ubuntu DISTRIB_RELEASE=22.04 DISTRIB_CODENAME=jammy DISTRIB_DESCRIPTION=\u0026#34;Ubuntu 22.04.3 LTS\u0026#34; ubuntu@ip-xxx-xxx-xxx-xxx:~$ Each proxy run with screen program, so when client disconnected, can be returned in current workspace.\nExample :\nOpen tuic workspace :\n1 screen -R tuic Minimize workspace :\nsend keyboard event CTRL+A then CTRL+D\nReturn workspace :\n1 screen -R tuic Usefull when need for debuging purpose.\nTUIC Source : https://github.com/chika0801/tuic-install/tree/main\nStandalone installation 1 2 3 4 5 cd /root/ mkdir tuic cd tuic wget https://github.com/EAimTY/tuic/releases/latest/download/tuic-server-1.0.0-x86_64-unknown-linux-gnu chmod +x tuic-server-1.0.0-x86_64-unknown-linux-gnu Download config :\n1 curl -Lo config_tuic.json https://raw.githubusercontent.com/chika0801/tuic-install/main/config_server.json Or create new file config_tuic.json :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { \u0026#34;server\u0026#34;: \u0026#34;[::]:443\u0026#34;, \u0026#34;users\u0026#34;: { \u0026#34;ee48f7be-6ae9-5654-9b61-8466aa8e16bc\u0026#34;: \u0026#34;chika\u0026#34; }, \u0026#34;certificate\u0026#34;: \u0026#34;/root/tuic/cert.pem\u0026#34;, \u0026#34;private_key\u0026#34;: \u0026#34;/root/tuic/key.pem\u0026#34;, \u0026#34;congestion_control\u0026#34;: \u0026#34;bbr\u0026#34;, \u0026#34;alpn\u0026#34;: [\u0026#34;h3\u0026#34;], \u0026#34;log_level\u0026#34;: \u0026#34;info\u0026#34; } ```shell Generate your certificate then save as `/root/tuic/cert.pem` and `/root/tuic/cert.pem`. Or generate self-signed certificate with : ```shell openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -sha256 -days 3650 -nodes -subj \u0026#34;/C=XX/ST=StateName/L=CityName/O=CompanyName/OU=CompanySectionName/CN=CommonNameOrHostname\u0026#34; Run your TUIC server :\n1 ./tuic-server-1.0.0-x86_64-unknown-linux-gnu -c config_tuic.json Configure Client Android Use NekoBox 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;relay\u0026#34;: { \u0026#34;server\u0026#34;: \u0026#34;chika.example.com:443\u0026#34;, \u0026#34;uuid\u0026#34;: \u0026#34;ee48f7be-6ae9-5654-9b61-8466aa8e16bc\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;chika\u0026#34;, \u0026#34;ip\u0026#34;: \u0026#34;10.0.0.1\u0026#34;, \u0026#34;congestion_control\u0026#34;: \u0026#34;bbr\u0026#34;, \u0026#34;alpn\u0026#34;: [\u0026#34;h3\u0026#34;] }, \u0026#34;local\u0026#34;: { \u0026#34;server\u0026#34;: \u0026#34;127.0.0.1:50000\u0026#34; }, \u0026#34;log_level\u0026#34;: \u0026#34;info\u0026#34; } Configure as needed.\nShadowTLS Reference :\nhttps://github.com/ihciah/shadow-tls/wiki/Run-with-Docker-Compose https://github.com/ihciah/shadow-tls/issues/70 How to Run · ihciah/shadow-tls Wiki · GitHub https://github.com/ihciah/shadow-tls/blob/master/docker-compose.yml GitHub - ihciah/shadow-tls: A proxy to expose real tls handshake to the firewall Prerequisites:\nInstall Docker both server and client side.\n1 sudo apt install docker-compose VPS :\nCreate a file docker-compose.yml and fill it with the following code:\nExample 1 :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 version: \u0026#39;3.5\u0026#39; services: shadowsocks: image: shadowsocks/shadowsocks-libev restart: always command: /bin/sh -c \u0026#39;exec ss-server -s 0.0.0.0 -p 24000 -k EXAMPLE_PASSWORD_SS -m chacha20-ietf-poly1305 -t 300\u0026#39; shadow-tls: image: ghcr.io/ihciah/shadow-tls:latest restart: always ports: - \u0026#34;8443:8443\u0026#34; environment: - MODE=server # - V3=1 - LISTEN=0.0.0.0:8443 - SERVER=shadowsocks:24000 - TLS=cloud.tencent.com:443 - PASSWORD=EXAMPLE_PASSWORD_ST depends_on: - shadowsocks Example 2 :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 version: \u0026#39;3.5\u0026#39; services: shadowsocks: image: ghcr.io/shadowsocks/ssserver-rust:latest restart: always command: /bin/sh -c \u0026#39;exec ssserver -s \u0026#34;[::]:24000\u0026#34; -k \u0026#34;3SYJ/f8nmVuzKvKglykRQDSgg10e/ADilkdRWrrY\u0026gt; shadow-tls: image: ghcr.io/ihciah/shadow-tls:latest restart: always ports: - \u0026#34;443:443\u0026#34; environment: - STRICT=1 - MODE=server - V3=1 - FASTOPEN=true - WILDCARD_SNI=all - LISTEN=0.0.0.0:443 - SERVER=shadowsocks:24000 - TLS=google.com:443 - PASSWORD=st depends_on: - shadowsocks Run container with :\n1 docker-compose up -d Client Linux Create file docker-compose.yml and fill it with the following code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 version: \u0026#39;3.5\u0026#39; services: shadow-tls: image: ghcr.io/ihciah/shadow-tls:latest restart: always ports: - \u0026#34;3443:3443\u0026#34; environment: - MODE=client # - V3=1 - LISTEN=0.0.0.0:3443 - SERVER=YOUR_VPS_IP:8443 - TLS=cloud.tencent.com - PASSWORD=EXAMPLE_PASSWORD_ST shadowsocks: image: shadowsocks/shadowsocks-libev restart: always command: /bin/sh -c \u0026#39;exec ss-local -b 0.0.0.0 -l 1080 -s shadow-tls -p 3443 -k EXAMPLE_PASSWORD_SS -m chacha20-ietf-poly1305 -t 300\u0026#39; ports: - \u0026#34;1080:1080\u0026#34; depends_on: - shadow-tls Run :\n1 docker-compose up -d Verify connection success :\n1 curl ipinfo.io -x socks5h://127.0.0.1:1080 -v Notes:\nStop docker:\n1 docker-compose down Remove docker:\n1 2 3 docker-compose down sudo apt remove docker docker-compose sudo apt autoremove Connect IP_VPS:3443 with shadowsocks protocol on your mobile phones or PCs will work or connect IP_VPS:1080 with sock5h protocol on browser proxy. I use Windows, I use Docker for Windows.\nAndroid Configuration Reference :\nShadowTLS - sing-box With NekoBox.apk then use this config template :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 { \u0026#34;dns\u0026#34;: { \u0026#34;fakeip\u0026#34;: { \u0026#34;enabled\u0026#34;: true, \u0026#34;inet4_range\u0026#34;: \u0026#34;198.18.0.0/15\u0026#34;, \u0026#34;inet6_range\u0026#34;: \u0026#34;fc00::/18\u0026#34; }, \u0026#34;independent_cache\u0026#34;: true, \u0026#34;rules\u0026#34;: [ { \u0026#34;disable_cache\u0026#34;: true, \u0026#34;inbound\u0026#34;: [ \u0026#34;tun-in\u0026#34; ], \u0026#34;server\u0026#34;: \u0026#34;dns-fake\u0026#34; } ], \u0026#34;servers\u0026#34;: [ { \u0026#34;address\u0026#34;: \u0026#34;https://8.8.8.8/dns-query\u0026#34;, \u0026#34;address_resolver\u0026#34;: \u0026#34;dns-direct\u0026#34;, \u0026#34;strategy\u0026#34;: \u0026#34;ipv4_only\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;dns-remote\u0026#34; }, { \u0026#34;address\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;address_resolver\u0026#34;: \u0026#34;dns-local\u0026#34;, \u0026#34;detour\u0026#34;: \u0026#34;direct\u0026#34;, \u0026#34;strategy\u0026#34;: \u0026#34;ipv4_only\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;dns-direct\u0026#34; }, { \u0026#34;address\u0026#34;: \u0026#34;local\u0026#34;, \u0026#34;detour\u0026#34;: \u0026#34;direct\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;dns-local\u0026#34; }, { \u0026#34;address\u0026#34;: \u0026#34;rcode://success\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;dns-block\u0026#34; }, { \u0026#34;address\u0026#34;: \u0026#34;fakeip\u0026#34;, \u0026#34;strategy\u0026#34;: \u0026#34;ipv4_only\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;dns-fake\u0026#34; } ] }, \u0026#34;inbounds\u0026#34;: [ { \u0026#34;listen\u0026#34;: \u0026#34;0.0.0.0\u0026#34;, \u0026#34;listen_port\u0026#34;: 6450, \u0026#34;override_address\u0026#34;: \u0026#34;8.8.8.8\u0026#34;, \u0026#34;override_port\u0026#34;: 53, \u0026#34;tag\u0026#34;: \u0026#34;dns-in\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;direct\u0026#34; }, { \u0026#34;domain_strategy\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;endpoint_independent_nat\u0026#34;: true, \u0026#34;inet4_address\u0026#34;: [ \u0026#34;172.19.0.1/28\u0026#34; ], \u0026#34;mtu\u0026#34;: 9000, \u0026#34;sniff\u0026#34;: true, \u0026#34;sniff_override_destination\u0026#34;: false, \u0026#34;stack\u0026#34;: \u0026#34;mixed\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;tun-in\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;tun\u0026#34; }, { \u0026#34;domain_strategy\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;listen\u0026#34;: \u0026#34;0.0.0.0\u0026#34;, \u0026#34;listen_port\u0026#34;: 2080, \u0026#34;sniff\u0026#34;: true, \u0026#34;sniff_override_destination\u0026#34;: false, \u0026#34;tag\u0026#34;: \u0026#34;mixed-in\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;mixed\u0026#34; } ], \u0026#34;log\u0026#34;: { \u0026#34;level\u0026#34;: \u0026#34;trace\u0026#34; }, \u0026#34;outbounds\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;shadowsocks\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;proxy\u0026#34;, \u0026#34;method\u0026#34;: \u0026#34;2022-blake3-chacha20-poly1305\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;3SYJ/f8nmVuzKvKglykRQDSgg10e/ADilkdRWrrY9HU=\u0026#34;, \u0026#34;detour\u0026#34;: \u0026#34;shadowtls-out\u0026#34;, \u0026#34;multiplex\u0026#34;: { \u0026#34;enabled\u0026#34;: false, \u0026#34;max_connections\u0026#34;: 4, \u0026#34;min_streams\u0026#34;: 4 } }, { \u0026#34;domain_strategy\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shadowtls\u0026#34;, \u0026#34;tag\u0026#34;: \u0026#34;shadowtls-out\u0026#34;, \u0026#34;server\u0026#34;: \u0026#34;IP_VPS\u0026#34;, \u0026#34;server_port\u0026#34;: 443, \u0026#34;version\u0026#34;: 3, \u0026#34;password\u0026#34;: \u0026#34;st\u0026#34;, \u0026#34;tls\u0026#34;: { \u0026#34;enabled\u0026#34;: true, \u0026#34;insecure\u0026#34;: true, \u0026#34;server_name\u0026#34;: \u0026#34;google.com\u0026#34;, \u0026#34;utls\u0026#34;: { \u0026#34;enabled\u0026#34;: true, \u0026#34;fingerprint\u0026#34;: \u0026#34;chrome\u0026#34; } } }, { \u0026#34;tag\u0026#34;: \u0026#34;direct\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;direct\u0026#34; }, { \u0026#34;tag\u0026#34;: \u0026#34;bypass\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;direct\u0026#34; }, { \u0026#34;tag\u0026#34;: \u0026#34;block\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;block\u0026#34; }, { \u0026#34;tag\u0026#34;: \u0026#34;dns-out\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;dns\u0026#34; } ], \u0026#34;route\u0026#34;: { \u0026#34;auto_detect_interface\u0026#34;: true, \u0026#34;rules\u0026#34;: [ { \u0026#34;outbound\u0026#34;: \u0026#34;dns-out\u0026#34;, \u0026#34;port\u0026#34;: [ 53 ] }, { \u0026#34;inbound\u0026#34;: [ \u0026#34;dns-in\u0026#34; ], \u0026#34;outbound\u0026#34;: \u0026#34;dns-out\u0026#34; }, { \u0026#34;ip_cidr\u0026#34;: [ \u0026#34;224.0.0.0/3\u0026#34;, \u0026#34;ff00::/8\u0026#34; ], \u0026#34;outbound\u0026#34;: \u0026#34;block\u0026#34;, \u0026#34;source_ip_cidr\u0026#34;: [ \u0026#34;224.0.0.0/3\u0026#34;, \u0026#34;ff00::/8\u0026#34; ] } ] } } Shadowsocks-rust Shadowsocks rust version is more updated version.\nServer Reference : https://crates.io/crates/shadowsocks-rust\nCreate config :\n1 2 3 4 5 6 { \u0026#34;server\u0026#34;:\u0026#34;0.0.0.0\u0026#34;, \u0026#34;server_port\u0026#34;:80, \u0026#34;password\u0026#34;:\u0026#34;x\u0026#34;, \u0026#34;method\u0026#34;:\u0026#34;chacha20-ietf-poly1305\u0026#34; } Download binary :\n1 2 3 4 5 6 mkdir /root/shadowsocks/ cd /root/shadowsocks/ wget https://github.com/shadowsocks/shadowsocks-rust/releases/download/v1.16.2/shadowsocks-v1.16.2.x86_64-unknown-linux-musl.tar.xz tar -xf shadowsocks-v1.16.2.x86_64-unknown-linux-musl.tar.xz chmod +x ssserver ./ssserver -c config.json Client Android : Use NekoBox.apk\nBrook Reference :\nGitHub - txthinking/brook: A cross-platform programmable network tool. 一个跨平台可编程网络工具. Server Quick download and run :\n1 2 3 wget https://github.com/txthinking/brook/releases/download/v20230606/brook_linux_amd64 chmod +x brook_linux_amd64 ./brook_linux_amd64 server -l :80 -p x Other method to run is install nami for download brook :\n1 2 3 bash \u0026lt;(curl https://bash.ooo/nami.sh) nami install brook brook server -l :9999 -p hello Or you can download from latest release : Releases · txthinking/brook · GitHub\nClient At example I\u0026rsquo;m using cli version :\n1 ./brook_linux_arm7 client -s=\u0026#34;IP_SERVER:80\u0026#34; -p x --socks5=\u0026#34;127.0.0.1:1080\u0026#34; --udpovertcp Then verify connection success with curl command :\n1 curl -x socks5h://127.0.0.1:1080 http://ipinfo.io -v Various Client can download here : Releases · txthinking/brook · GitHub\nQuick Link :\nApple Android MAC Windows Linux [OpenWRT](Releases · txthinking/brook · GitHub) Various Running Mode In order to use SSL, lets generate self-signed certificate for testing environment, my current brook workspace is /root/brook/.\n1 openssl req -x509 -newkey rsa:4096 -keyout /root/brook/key.pem -out /root/brook/cert.pem -sha256 -days 3650 -nodes -subj \u0026#34;/C=XX/ST=StateName/L=CityName/O=CompanyName/OU=CompanySectionName/CN=CommonNameOrHostname\u0026#34; WebSocket Server Command :\n1 ./brook_linux_amd64 wsserver -l :80 -p x Client Command :\n1 ./brook_linux_arm7 wsclient -s=\u0026#34;ws://IP_SERVER:80\u0026#34; -p x --socks5=\u0026#34;127.0.0.1:1080\u0026#34; WebSocket Secure Server Command :\n1 ./brook_linux_amd64 wssserver --domainaddress example.com:443 --cert /root/brook/cert.pem --certkey /root/brook/key.pem -p x Client Command :\n1 ./brook_linux_arm7 wssclient --wssserver \u0026#34;wss://example.com\u0026#34; --address \u0026#34;IP_SERVER:443\u0026#34; --insecure -p x --socks5=\u0026#34;127.0.0.1:1080\u0026#34; QUIC Server Server Command :\n1 ./brook_linux_amd64 quicserver --domainaddress example.com:443 -p x Client Command :\n1 ./brook_linux_arm7 quicclient --quicserver \u0026#34;quic://example.com:443\u0026#34; --address \u0026#34;IP_SERVER:443\u0026#34; --insecure -p x --socks5=\u0026#34;127.0.0.1:1080\u0026#34; RESTLS Ref :\nhttps://github.com/3andne/restls\nRun shadowsocks server Create config.json in /root/shadowsocks :\n1 2 3 4 5 6 { \u0026#34;server\u0026#34;:\u0026#34;0.0.0.0\u0026#34;, \u0026#34;server_port\u0026#34;:8888, \u0026#34;password\u0026#34;:\u0026#34;x\u0026#34;, \u0026#34;method\u0026#34;:\u0026#34;chacha20-ietf-poly1305\u0026#34; } Download and unzip Shadowsocks-rust :\n1 2 3 4 wget https://github.com/shadowsocks/shadowsocks-rust/releases/download/v1.16.2/shadowsocks-v1.16.2.x86_64-unknown-linux-musl.tar.xz tar -xf shadowsocks-v1.16.2.x86_64-unknown-linux-musl.tar.xz chmod +x ssserver ./ssserver -c config.json Dont forget to run as screen.\nRun restls server Latest release : https://github.com/3andne/restls/releases\n1 2 3 4 mkdir /root/restls cd /root/restls wget https://github.com/3andne/restls/releases/download/v0.1.1/restls-x86_64-unknown-linux-musl chmod +x restls-x86_64-unknown-linux-musl Client You will need this Release Clash.Meta with Restls Support · 3andne/Clash.Meta · GitHub\nExample Configuration :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 port: 7890 socks-port: 7891 redir-port: 7892 mixed-port: 7893 tproxy-port: 7895 ipv6: false mode: rule log-level: silent allow-lan: true external-controller: 0.0.0.0:9090 ## external-ui: /path/to/ui/folder/ ## external-ui-name: xd ## external-ui-url: \u0026#34;https://github.com/MetaCubeX/metacubexd/archive/refs/heads/gh-pages.zip\u0026#34; secret: \u0026#34;\u0026#34; bind-address: \u0026#34;*\u0026#34; unified-delay: true profile: store-selected: true dns: enable: true ipv6: false enhanced-mode: redir-host listen: 0.0.0.0:7874 nameserver: - 8.8.8.8 - 1.0.0.1 - https://dns.google/dns-query fallback: - 1.1.1.1 - 8.8.4.4 - https://cloudflare-dns.com/dns-query - 112.215.203.254 default-nameserver: - 8.8.8.8 - 1.1.1.1 - 112.215.203.254 proxies: - name: restls-tls13 type: ss server: 54.169.105.185 port: 443 cipher: chacha20-ietf-poly1305 password: x plugin: restls plugin-opts: host: \u0026#34;www.microsoft.com\u0026#34; # Must be a TLS 1.3 server password: x version-hint: \u0026#34;tls13\u0026#34; client-id: chrome # One of: chrome, ios, firefox or safari - name: restls-tls12 type: ss server: 54.169.105.185 port: 443 cipher: chacha20-ietf-poly1305 password: x plugin: restls plugin-opts: host: \u0026#34;vscode.dev\u0026#34; # Must be a TLS 1.2 server password: x version-hint: \u0026#34;tls12\u0026#34; client-id: firefox # One of: chrome, ios, firefox or safari proxy-groups: - name: RESTLS type: select proxies: - restls-tls13 - restls-tls12 - DIRECT rules: - MATCH,RESTLS The connection is unstable.\nQuick Install GitHub - aleskxyz/reality-ezpz: Install sing-box/xray and configure vless / tuic / hysteria2 for reality or tls (letsencrypt) over different transport protocols (tcp, http, grpc and websocket) with user management capability in CLI, TUI and Telegram bot by a single command in docker compose!\n","date":"2023-11-30T23:58:43+07:00","permalink":"https://anasfanani.com/en/p/various-open-source-proxy-installation/","title":"Various Open Source Proxy Installation"},{"content":"ShadowTLS - a better TLS masquerading proxy This article is translated from original page here https://www.ihcblog.com/a-better-tls-obfs-proxy/\nIf you want skip read this just go click Quick Start\nThis article mainly analyzes the currently popular Trojan protocol and tries to propose a better solution based on the characteristics of the current middleman.\nThe implementation of this solution is ShadowTLS, and you can find the full code and precompiled binaries on Github .\nTo hide traffic characteristics, one way is not to expose any characteristics, that is, shadowsocks: this type of protocol also encrypts the protocol header for transmission, so no obvious characteristics can be observed. The second way is to hide yourself among others. The simplest way is to disguise it as HTTP or TLS traffic, corresponding to simple-obfs and Trojan respectively.\nMethod 1 is now relatively easy to identify. It does not hit any protocol and the timing characteristics are consistent with web traffic. It is enough to think that it is this type of traffic. Method 2 has become more and more mainstream in recent years, and the most widely used one is the Trojan protocol (simple-obfs just adds an http protocol header at the beginning, which is too easy to identify and will not be analyzed here).\nHow Trojans work What the Trojan wants to do is encapsulate the traffic into a normal TLS traffic. Because TLS traffic is encrypted, it is difficult for a middleman to identify whether it is ordinary web traffic or encapsulated proxy traffic. In order to be more similar, Trojan also defends against active detection, and the browser can directly open the corresponding web page and respond normally.\nSo the main problems it wants to solve here are these:\nProxy request bearer: To be able to encode the proxy request into binary, the server side must be able to decode the request, establish a remote connection and relay traffic according to the request. Distinguish between client and active probe traffic: Some means is needed to distinguish client requests and active probe requests, and handle them differently. Subsequent processing of client and active detector traffic: The differentiated traffic is processed separately. Client traffic needs to be carried using the TLS protocol, and active detector traffic also needs to be able to act like http. The official protocol specification is written here: The Trojan Protocol . Solving problem 1 is very simple, because the upper layer is exposed to the socks5 proxy, so just package the socks5 proxy request header directly (similar to shadowsocks).\nThe focus is on questions 2 and 3. The method here is to first establish a TLS session, and then use the first 56 bytes in the TLS connection for authentication. If these 56 bytes match a certain hash result of our preshared key, then we think that this traffic is sent by our client.\nIt is obvious that people will notice a problem here: As an attacker, after establishing a TLS session and sending an HTTP request smaller than 56 bytes, I can determine whether it is a Trojan server by determining whether it is stuck? Because it takes 56 bytes to distinguish who I am, routing cannot be done before the data reaches 56 bytes.\nIn fact this problem does not exist. Let\u0026rsquo;s take a look at the details of the protocol design: this 56 byte is hex(SHA224(password)), and CRLF will be sent later. Isn\u0026rsquo;t it strange? Why does a binary protocol need CRLF, something that only text protocols use? And isn\u0026rsquo;t it more efficient to directly send SHA224 binary results than to send hex? In fact, this is the subtlety of protocol design.\nThis CRLF is actually designed to correspond to HTTP traffic. When processing on the server side, directly read_until CRLF, and then routing can be done. Because HTTP traffic must be processed after it sends CRLF.\nSo after reading the first CRLF, either hex(SHA224(password)) has been sent, or the first line of the HTTP request has been sent. In either case, we can already make routing distinctions. For example, if we find that the data is not enough for 56 bytes, we can directly determine it as actively detecting traffic without having to wait for 56 bytes to be received. And why hex is needed is to avoid the accidental inclusion of CRLF in the hash result affecting our judgment.\nBy the way, a digression: When researching this protocol, I read the implementation of the trojan c and go versions. In fact, there is a problem with the implementation of the golang version. Maybe the author did not get these tricks in the protocol design. It directly does a read. If the data is not enough or the hash does not match, it is determined as active detection of traffic. But we cannot take reading 56 bytes at a time for granted. TCP is a stream protocol, and reading 1 byte at a time is the return result that complies with the POSIX specification.\nErrata: After correction by netizen RPRX, the statement here is indeed wrong. What is read and written here is not the naked TCP flow but the TLS flow. TLS traffic itself is framed, which theoretically guarantees one-to-one correspondence between reading and writing.Errata: After correction by netizen RPRX, the statement here is indeed wrong. What is read and written here is not the naked TCP flow but the TLS flow. TLS traffic itself is framed, which theoretically guarantees one-to-one correspondence between reading and writing.\nGolang\u0026rsquo;s official TLS library exposes an interface to the outside world io.Reader. io.WriterThis interface is a streaming interface and the officially implemented TLS library does not guarantee a corresponding relationship. Therefore, the statement here should be corrected to rely on specific behaviors under specific conditions rather than dependence on the interface.\nWhat\u0026rsquo;s wrong with Trojan Everything looks fine? We package all data into TLS, and the outside world cannot tell what the encrypted data is. It seems that we have been requesting a certain web site, and if we browse the web, the timing characteristics of the proxy traffic are also web traffic.\nIf you ignore some implementation features, the only thing exposed here is the SNI and the corresponding certificate. The target domain name of our request will be exposed in TLS Client Hello, and it may not be normal to request a niche domain name with large traffic for a long time.\nbetter ways to disguise Is there a better way to disguise it? If we want to use TLS, we have to handle the handshake ourselves; if we want to handshake, we have to issue a certificate with our own domain name. It seems to be an unsolvable problem. .\nOh wait! We are just pretending to be TLS traffic, who says we really need to use TLS?\nSo can we do a \u0026ldquo;TLS show\u0026rdquo; to show the middleman? The server can directly proxy this performance data to the whitelisted servers of some large companies or institutions, so that the handshake seen by the middleman is a handshake with a legitimate certificate and a whitelisted domain name. After the handshake is completed, the client and server switch modes and use the established connection to transmit custom data.\nSwitching mode requires that both parties can sense the end of the handshake. Here we force the use of TLS1.2. After observing a Change Cipher Spec packet, read another Handshake packet to mark the completion of the handshake.\nWe don\u0026rsquo;t want to implement data encryption and proxy protocol encapsulation ourselves, so the custom data here is directly processed by shadowsocks. Our ShadowTLS works as a wrapper for shadowsocks traffic. For the client, it adds a layer of handshake data to the traffic, and for the server, it strips off this layer of handshake data.\nSo far, if we assume the middleman:\nNo analysis of traffic after handshake No active detection Then our protocol works very efficiently. From the packet capture, we can see that we are really communicating with a trusted domain name through TLS from a man-in-the-middle perspective. According to feedback, this version from late August to early October 2022 has helped some people get rid of QoS issues for domain names.\nProblems with ShadowTLS protocol (v1) Previously we only did a very simple \u0026ldquo;performance\u0026rdquo; and made two assumptions, but in fact these two assumptions are not true. We need to be able to deal with both of these issues.\nDealing with traffic analysis Normal TLS data will be communicated using the Application Data encapsulation package after the handshake is completed. Directly forwarding the shadowsocks data stream is completely inconsistent with the TLS protocol, and even wireshark will highlight subsequent data packets to indicate a problem. It is not difficult to solve this problem. We only need to encapsulate and decapsulate on both sides.\nRespond to active detection If we are to be able to deal with active detection, we need to be able to do two things (the same as Trojan needs to do):\nDistinguish between client traffic and active detection traffic Correctly respond to proactive probe traffic We need the client to give something special to judge that this is our client traffic. In order to avoid active detection, we must introduce a pre-shared key. But how?\nIn the Trojan protocol, just send the hash of the password directly. But we only have plaintext channels available here, so sending the hash of the password directly obviously exposes the password, which means that the password is no longer meaningful; and it is completely unable to prevent data replay.\nShadowTLS v2 protocol design Server Challenge Based on the plain text channel, we can only authenticate in the form of challenge-response. Normally, if we want to authenticate the client, we need the server to send a challenge. But in fact we cannot do this, because a normal https server cannot send back a challenge after the TLS handshake.\nSo can the challenge be hidden in a normal handshake? The requirements for the challenge are very simple, just be random and uncontrollable by the client. My idea is that in fact, the data sent by the server during the handshake process itself can be used as a challenge: it has random data, such as server random, and it is not controllable by the client.\nHere I use all the data sent by the server during the handshake process as a challenge (of course, server random can also be used, but this requires parse TLS packets and awareness of TLS protocol details, which is a bit troublesome to implement and may introduce feature differentiation in details), like this The dependence on the details of the TLS protocol can be weakened as much as possible, so there is no need to rely on the details of the handshake behavior of TLS1.2.\nClient Response We have a challenge, so how to respond? Obviously we need to authenticate the pre-shared key, so we hmac(data, key) can use it directly as the response (it can be simply understood as hash(data+key), but it is better in terms of security, it can be obtained by streaming calculation, and there is no need to cache data).\nHow to send this Response data back? If used as separate packets, new distinguishing characteristics are introduced. So here we put this Response in the header of the first Application Data packet and send it to the Server side.\nFor this hmac, I use the first 8 bytes of hmac-sha1, and the security is good enough.\nApplication Data During the data forwarding process, Application Data is encapsulated and decapsulated. The question that needs to be considered here is, how big is a single Application Data packet under normal circumstances? In the current implementation, a buffer size is determined directly by tapping the head. However, in order to prevent this packet size from becoming a feature, it is necessary to investigate the implementation of the TLS library and capture packets to observe and determine a reasonable maximum value.\nHandling active probe traffic We can simplify the server model as follows: connect to the handshake server by default; switch to the data server if the hmac authentication passes.\nFor active detection traffic, it is impossible for it to guess the 8 byte hmac correctly, so it will never switch to the data server. In order to avoid unnecessary hash calculations, when the first N Application Data packets fail to pass the hmac verification (N is taken here instead of 1 because it is not sure whether the Application Data is sent, it must mark the end of the handshake), it will switch directly to Direct proxy, no further attempts to hmac calculation and verification will be made.\nThe detailed protocol design is written here , you can refer to it if you are interested.\nShadowTLS vs. Trojan Compared with Trojan, ShadowTLS does not need to issue a certificate by itself (you can directly use the trusted domain name of a large company or institution), nor does it need to start a disguised HTTP service by itself (because the data is directly forwarded to the website corresponding to the trusted domain name). Using a trusted domain name can Further weaken the features and hide the trees in the forest.\nBoth ShadowTLS and Trojan can handle active detection, and when opened directly using a browser, the HTTP page can be accessed normally.\nGo further UPDATED AT 2022-11-13\nMore than a month has passed since the v2 implementation was released, and ShadowTLS has achieved good results: when Trojan was banned on a large scale in the past period, ShadowTLS is still available. Currently, both ShadowRocket and Surge support this protocol (although I still have no money to buy Surge).\nBut in fact, there are many areas that can be improved:\nTLS fingerprinting issue For Server, we forward traffic directly, and there is no fingerprint problem; but Client is implemented by ourselves, and we expect it to look the same as a browser or other normal client, but in fact it may not be similar enough. If you capture the packet and look at the Client Hello packet sent by Chrome, you can clearly see that it contains a lot of Extension fields, and these fields are not automatically attached when we use rustls; and the default selection of Cipher and Hash for different clients Lists etc are different.\nSo one area that can be improved is to provide multiple Client TLS Profiles for users to choose from.\nTraffic hijacking problem This issue mentioned a real problem: What if someone hijacks client-side traffic to the handshake server?\nFirst, who does the Client trust? Until it completes the TLS handshake, it behaves like a normal TLS Client. To gain the client\u0026rsquo;s trust, you first need to be able to pass certificate verification and complete the TLS handshake. In addition to our Server, the people who can do this include the handshake server itself, and other intermediaries that proxy the handshake.\nI think we can assume here that the handshake server is not controllable by the middleman, and its certificate cannot be held by the middleman. So now the focus is on the middlemen who act as agents of handshake like us. The man-in-the-middle does not need to decrypt the traffic, its goal is to identify whether we are a normal connection. So although it does not get the decryption key, it can still hijack and replay the traffic to achieve its goal:\nDirectly hijack the entire connection to the handshake server (this is the attack method mentioned in the issue): the secret will be exposed after the Client completes the protocol switch, and the handshake server will return Encrypted Alert. Normally proxy traffic, but secretly lose or reorder an Application Data: Normally, Encrypted Alert should be returned, but because we do not do message Authentication or Encryption, we are actually not aware of this matter. This matter will Being thrown to lower level services. We rely on the underlying service to disconnect to return Encrypted Alert. Observing disconnected connections: As mentioned in 2, we need to properly handle the problem of disconnected connections, whether it is a normal shutdown or an abnormal shutdown. But the current implementation does not send Encrypted Alert. Merge adjacent Application Data: Under normal circumstances, there will be a sequence number and MAC inside the TLS protocol, but our encapsulation currently does not, so if the hijacker merges adjacent Application Data and the connection is still normal, then it can also be found to be disguised TLS. However, these problems (except problem 3) need to be able to hijack traffic on the main link to take effect. If there are no other hints, hijacking all outbound TLS traffic is still very risky. So I think this problem is actually not a big one.\nWhat\u0026rsquo;s Better Protocol? We can simply fix some of the problems mentioned earlier (these are implementation issues, not protocol issues): provide Client TLS Profile and send Encrypted Alert when the connection is closed. But what about the remaining traffic hijacking issues?\nAgainst attacks that hijack directly to the handshake server We can see that the key to the problem is that the Client did not authenticate the Server (only the certificate was authenticated). The server needs to indicate its identity. If it is placed in an Extension in Server Hello, it may become an obvious feature; if it is directly included in subsequent traffic, it will also confuse the detector and prevent normal decryption.\nWe need a place like this: it is sent by the Server, it is a random number itself, and it has no effect if we modify it. It is best to send it after sending the Server Random (this way you can use Server Random to defend against replay attacks). We can actually hide some things on IP packets, but this requires us to have system administrator rights and will introduce stronger environmental restrictions, so we try our best to find such places on top of TCP.\nSo we can find a hiding point that meets the conditions: Session ID (Session ID for TLS 1.3 only). Since we fully trust that Server Random must be Random, we can do something simpler here: if the relayed Server Hello packet contains a 32-bit Session ID, replace the ID with the HMAC of Server Random. Since TLS 1.2 defaults to this field being empty, we cannot rashly insert this value for TLS 1.2 to avoid becoming a feature.\nReshape for traffic Our Application Data encapsulation can be reshaped, but real TLS traffic cannot, so we need to refer to the TLS approach in this layer of encapsulation and carry some data for verification. This kind of verification helps to find problems 2 and 4 mentioned above, and then you only need to respond to the Alert and disconnect.\nOf course, these have not been implemented yet (until 2022-11-13). If you are interested, you are welcome to raise an issue to claim your contribution!\nImplementing fixes and preventing direct hijacking to the handshake server can maintain compatibility with older versions of Client, but if you want to add MAC to Application Data, you have to change the protocol (maybe v3) ~\nSummarize ShadowTLS is implemented based on Rust + Monoio, and can bring better IO performance based on io_uring and thread-per-core models (but because Monoio currently does not support Windows, Windows users cannot use it for the time being, and it is recommended to use wsl ) .\nIn summary, this article attempts to analyze the mainstream TLS-based proxy protocol, proposes a better protocol design for its possible defects, and provides the corresponding implementation. You can find the corresponding code here .\nQuick Start I\u0026rsquo;m having trouble understanding the original tutorial from here https://github.com/ihciah/shadow-tls/wiki/Run-with-Docker-Compose then I looked for a way how I can try shadowtls running on a vps server and I can use it in seconds.\nI saw the issue in the shadowtls repository https://github.com/ihciah/shadow-tls/issues/70\nthere he gives a good quick start to trying out shadow tls. Maybe you can follow the method from that page directly or follow the method that I tried which is currently successful.\nPrerequisites:\nA VPS \u0026amp; Client with Docker and Docker Compose installed. Instructions:\nOn the VPS, create a file called docker-compose.yml and fill it with the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 version: \u0026#39;3.5\u0026#39; services: shadowsocks: image: shadowsocks/shadowsocks-libev restart: always command: /bin/sh -c \u0026#39;exec ss-server -s 0.0.0.0 -p 24000 -k EXAMPLE_PASSWORD_SS -m chacha20-ietf-poly1305 -t 300\u0026#39; shadow-tls: image: ghcr.io/ihciah/shadow-tls:latest restart: always ports: - \u0026#34;8443:8443\u0026#34; environment: - MODE=server # - V3=1 - LISTEN=0.0.0.0:8443 - SERVER=shadowsocks:24000 - TLS=cloud.tencent.com:443 - PASSWORD=EXAMPLE_PASSWORD_ST depends_on: - shadowsocks Replace the following values with your own (I suggest just copy and paste on your server, you can change later): EXAMPLE_PASSWORD_SS: The password for your Shadowsocks. EXAMPLE_PASSWORD_ST: The password for your ShadowTLS. TLS: The TLS domain for your ShadowTLS. Run the following command to start the Docker containers: 1 docker-compose up -d On your client computer, create a file called docker-compose.yml and fill it with the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 version: \u0026#39;3.5\u0026#39; services: shadow-tls: image: ghcr.io/ihciah/shadow-tls:latest restart: always ports: - \u0026#34;3443:3443\u0026#34; environment: - MODE=client # - V3=1 - LISTEN=0.0.0.0:3443 - SERVER=YOUR_VPS_IP:8443 - TLS=cloud.tencent.com - PASSWORD=EXAMPLE_PASSWORD_ST shadowsocks: image: shadowsocks/shadowsocks-libev restart: always command: /bin/sh -c \u0026#39;exec ss-local -b 0.0.0.0 -l 1080 -s shadow-tls -p 3443 -k EXAMPLE_PASSWORD_SS -m chacha20-ietf-poly1305 -t 300\u0026#39; ports: - \u0026#34;1080:1080\u0026#34; depends_on: - shadow-tls Replace the following values with your own (I suggest just copy and paste on your client machine, you can change later): YOUR_VPS_IP: The IP address of your VPS. EXAMPLE_PASSWORD_SS: The password for your Shadowsocks server. EXAMPLE_PASSWORD_ST: The password for your ShadowTLS account. TLS: The TLS domain for your ShadowTLS account. Run the following command to start the Docker containers: 1 docker-compose up -d Once the Docker containers have started, you can verify the connection is success with curl :\nTo test the connection, run the following command:\n1 curl ipinfo.io -x socks5h://127.0.0.1:1080 -v If the connection is successful, you should see your IP address and other information about your connection.\nTo stop the Docker containers:\n1 docker-compose down Connect cn_vps:3443 with shadowsocks protocol on your mobile phones or PCs will work or connect cn_vps:1080 with sock5h protocol on browser proxy. I use Windows, I use Docker for Windows. Thank you, this post is just for personal reference if one day I forget how to install shadowtls.\n","date":"2023-10-07T20:28:20+07:00","permalink":"https://anasfanani.com/en/p/how-to-install-and-use-the-shadowtls-proxy/","title":"How to install and use the ShadowTLS Proxy"},{"content":"If you plan to migrate to new domain, this article is for you. follow me the steps.\nRequirements CloudFlare account. Your domain allready on CloudFlare. Steps Go to the cloudflare dashboard and select your old domain.\nNavigate to Rules \u0026gt; Redirect Rules.\nClick on Create Rule button.\nInput your Rule name (required), as example i will input movedomain\nWhen incoming requests match… select All incoming requests\nThen in URL redirect input this :\nName Value Type Dynamic Expression concat(\u0026ldquo;https://yournewdomain.com\u0026rdquo;, http.request.uri.path) Status code 301 In Checkbox Preserve query string dont forget to tick it.\nVerify redirect works with browse to your old domain name.\n","date":"2023-09-07T15:38:37+07:00","permalink":"https://anasfanani.com/en/p/redirect-all-url-while-migrate-to-new-domain/blog/","title":"Redirect all URL while migrate to new Domain/Blog"},{"content":"cPanel is a popular hosting control panel that provides a variety of features and tools to help you manage your website. However, the default cPanel redirect can be a security risk. This redirect sends users to the cPanel login page when they enter your domain name in their browser. This can make it easier for hackers to find your cPanel login information and your real IP address.\nTo hide the default cPanel redirect, you can use Cloudflare. Cloudflare is a content delivery network (CDN) that can help improve the performance and security of your website. To hide the default cPanel redirect with Cloudflare, follow these steps:\nRequirements A Cloudflare account. Your website must already be on Cloudflare. Steps Login to CloudFlare Go to the Cloudflare dashboard: https://dash.cloudflare.com/.\nCreate Rules Click on the Rules tab and select Transform Rules.\nScroll down to the Custom Records section.\nClick on the Create Rule button.\nIn the Name field, enter a name for the rule, such as Disable Default Redirect CPanel.\nIn the When incoming requests match… section, select Custom filter expression and click on Edit Expression. Enter the following value for the expression:\n1 2 (http.request.uri.path eq \u0026#34;/cpanel\u0026#34;) or (http.request.uri.path eq \u0026#34;/whm\u0026#34;) or (http.request.uri.path eq \u0026#34;/webmail\u0026#34;) This expression will match any request that comes in to the Cloudflare proxy with a URI path of /cpanel, /whm, or /webmail.\nIn the Path section, select Rewrite to… and select Static. Then, enter /not-found in the field below. This will tell Cloudflare to rewrite any requests that match the expression to a page with the URI path of /not-found.\nIn the Query section, select Preserve. This will ensure that any query parameters that are included in the request are also included in the rewritten request.\nClick on the Save button.\nThat\u0026rsquo;s it! Cloudflare will now redirect any requests that match the expression to a page with the URI path of /not-found. This will help to hide your cPanel login information and your real IP address from potential hackers.\n","date":"2023-09-06T15:29:24+07:00","permalink":"https://anasfanani.com/en/p/hide-default-cpanel-redirect-with-cloudflare/","title":"Hide default CPanel redirect with CloudFlare"},{"content":"Lets start with simple opening, we dont talk about what is Fiddler , we talk about how to redirect all traffict to proxy.\nLogin as root first.\n1 user@ubuntuserver:/home/user# sudo su First we need download redsocks and iptables in the Linux VM. Use this command apt install redsocks iptables -y\n1 root@ubuntuserver:/home/user# apt install redsocks iptables -y Then simply apply this code bellow, you can customize it for what you need.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 iptables -t nat -N REDSOCKS # Exclude local and reserved addresses iptables -t nat -A REDSOCKS -d 0.0.0.0/8 -j RETURN iptables -t nat -A REDSOCKS -d 10.0.0.0/8 -j RETURN iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN iptables -t nat -A REDSOCKS -d 169.254.0.0/16 -j RETURN iptables -t nat -A REDSOCKS -d 172.16.0.0/12 -j RETURN iptables -t nat -A REDSOCKS -d 192.168.0.0/16 -j RETURN iptables -t nat -A REDSOCKS -d 224.0.0.0/4 -j RETURN iptables -t nat -A REDSOCKS -d 240.0.0.0/4 -j RETURN # Now we need to add a rule that will redirect all packets from our custom REDSOCKS chain to the local port, we will use the default one – 12345 iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-ports 12345 # Redirect all HTTP and HTTPS outgoing packets through Redsocks # iptables -t nat -A OUTPUT -p tcp --dport 443 -j REDSOCKS # iptables -t nat -A OUTPUT -p tcp --dport 80 -j REDSOCKS # Redirect all HTTP and HTTPS incoming packets through Redsocks # iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDSOCKS # iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDSOCKS ## Filter all traffic from the own host ## BE CAREFULL HERE IF THE PROXY-SERVER RUNS ON THIS MACHINE iptables -t nat -A OUTPUT -p tcp -j REDSOCKS # Filter all traffic that is routed over this host iptables -t nat -A PREROUTING -p tcp -j REDSOCKS After all set, we need configure /etc/redsocks.conf Here the default configuration :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 base { // debug: connection progress \u0026amp; client list on SIGUSR1 log_debug = off; // info: start and end of client session log_info = on; /* possible `log\u0026#39; values are: * stderr * \u0026#34;file:/path/to/file\u0026#34; * syslog:FACILITY facility is any of \u0026#34;daemon\u0026#34;, \u0026#34;local0\u0026#34;...\u0026#34;local7\u0026#34; */ log = \u0026#34;syslog:daemon\u0026#34;; // detach from console daemon = on; /* Change uid, gid and root directory, these options require root * privilegies on startup. * Note, your chroot may requre /etc/localtime if you write log to syslog. * Log is opened before chroot \u0026amp; uid changing. */ user = redsocks; group = redsocks; // chroot = \u0026#34;/var/chroot\u0026#34;; /* possible `redirector\u0026#39; values are: * iptables - for Linux * ipf - for FreeBSD * pf - for OpenBSD * generic - some generic redirector that MAY work */ redirector = iptables; } redsocks { /* `local_ip\u0026#39; defaults to 127.0.0.1 for security reasons, * use 0.0.0.0 if you want to listen on every interface. * `local_*\u0026#39; are used as port to redirect to. */ local_ip = 127.0.0.1; local_port = 12345; // `ip\u0026#39; and `port\u0026#39; are IP and tcp-port of proxy-server // You can also use hostname instead of IP, only one (random) // address of multihomed host will be used. ip = 172.26.160.1; port = 8888; // known types: socks4, socks5, http-connect, http-relay type = http-connect; // login = \u0026#34;foobar\u0026#34;; // password = \u0026#34;baz\u0026#34;; } redudp { // `local_ip\u0026#39; should not be 0.0.0.0 as it\u0026#39;s also used for outgoing // packets that are sent as replies - and it should be fixed // if we want NAT to work properly. local_ip = 127.0.0.1; local_port = 10053; // `ip\u0026#39; and `port\u0026#39; of socks5 proxy server. ip = 192.0.2.1; port = 1080; login = username; password = pazzw0rd; // kernel does not give us this information, so we have to duplicate it // in both iptables rules and configuration file. By the way, you can // set `local_ip\u0026#39; to 127.45.67.89 if you need more than 65535 ports to // forward ;-) // This limitation may be relaxed in future versions using contrack-tools. dest_ip = 192.0.2.2; dest_port = 53; udp_timeout = 30; udp_timeout_stream = 180; } dnstc { // fake and really dumb DNS server that returns \u0026#34;truncated answer\u0026#34; to // every query via UDP, RFC-compliant resolver should repeat same query // via TCP in this case. local_ip = 127.0.0.1; local_port = 5300; } // you can add more `redsocks\u0026#39; and `redudp\u0026#39; sections if you need. In the /etc/redsocks.conf configuration, edit ip port type inside redsocks { } You can use nano or vim\n1 root@ubuntuserver:/home/user# nano /etc/redsocks.conf Then edit this :\n1 2 3 ip = 172.26.160.1; port = 8888; type = http-connect; this is our proxy configuration, if you dont know what the ip host (Windows host) inside VM, you can check it with CMD, type it ipconfig\nOutput is like this :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 C:UsersAdministrator\u0026gt;ipconfig Windows IP Configuration Ethernet adapter vEthernet (Default Switch): Connection-specific DNS Suffix . : Link-local IPv6 Address . . . . . : fe80::bf56:d73a:13b2:84ef%27 IPv4 Address. . . . . . . . . . . : 172.26.160.1 Subnet Mask . . . . . . . . . . . : 255.255.240.0 Default Gateway . . . . . . . . . : Ethernet adapter vEthernet (WSL): Connection-specific DNS Suffix . : Link-local IPv6 Address . . . . . : fe80::3100:e28a:3a04:80ad%36 IPv4 Address. . . . . . . . . . . : 172.20.48.1 Subnet Mask . . . . . . . . . . . : 255.255.240.0 Default Gateway . . . . . . . . . : After all set, restart the redsocks using pkill redsocks , then start again with redsocks\n1 2 3 root@ubuntuserver:/home/user# pkill redsocks root@ubuntuserver:/home/user# redsocks root@ubuntuserver:/home/user# Try to execute command like curl or wget (make sure proxy is running)\nexecute curl with proxy : curl --proxy 172.26.160.1:8888 google.com\n1 2 3 4 5 6 7 8 9 root@ubuntuserver:/home/user# curl --proxy 172.26.160.1:8888 google.com \u0026lt;HTML\u0026gt;\u0026lt;HEAD\u0026gt;\u0026lt;meta http-equiv=\u0026#34;content-type\u0026#34; content=\u0026#34;text/html;charset=utf-8\u0026#34;\u0026gt; \u0026lt;TITLE\u0026gt;301 Moved\u0026lt;/TITLE\u0026gt;\u0026lt;/HEAD\u0026gt;\u0026lt;BODY\u0026gt; \u0026lt;H1\u0026gt;301 Moved\u0026lt;/H1\u0026gt; The document has moved \u0026lt;A HREF=\u0026#34;http://www.google.com/\u0026#34;\u0026gt;here\u0026lt;/A\u0026gt;. \u0026lt;/BODY\u0026gt;\u0026lt;/HTML\u0026gt; root@ubuntuserver:/home/user# curl --proxy 172.26.160.1:8888 anasfanani.id root@ubuntuserver:/home/user# Off course we can see the traffict in fiddler proxy because we set --proxy in curl\nSo lets use curl without --proxy\n1 2 3 4 5 6 7 root@ubuntuserver:/home/user# curl google.com \u0026lt;HTML\u0026gt;\u0026lt;HEAD\u0026gt;\u0026lt;meta http-equiv=\u0026#34;content-type\u0026#34; content=\u0026#34;text/html;charset=utf-8\u0026#34;\u0026gt; \u0026lt;TITLE\u0026gt;301 Moved\u0026lt;/TITLE\u0026gt;\u0026lt;/HEAD\u0026gt;\u0026lt;BODY\u0026gt; \u0026lt;H1\u0026gt;301 Moved\u0026lt;/H1\u0026gt; The document has moved \u0026lt;A HREF=\u0026#34;http://www.google.com/\u0026#34;\u0026gt;here\u0026lt;/A\u0026gt;. \u0026lt;/BODY\u0026gt;\u0026lt;/HTML\u0026gt; Lets use with other linux program like php , execute php -r \u0026quot;echo file_get_contents('http://ifconfig.me');\u0026quot; and see the Fiddler\n1 root@ubuntuserver:/home/user# php -r \u0026#34;echo file_get_contents(\u0026#39;http://ifconfig.me\u0026#39;);\u0026#34; You can try see the packet from apt update or any other command.\nAll is set, simple, if you have questions, ask in comments. Thanks\n","date":"2022-12-09T02:48:17+07:00","permalink":"https://anasfanani.com/en/p/redirect-all-linux-traffict-to-http/https/socks-proxy-fiddlerburp/","title":"Redirect all Linux traffict to HTTP/HTTPS/Socks Proxy (Fiddler,Burp)"}]